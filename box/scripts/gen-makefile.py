#!/usr/bin/env python
# -*- coding: utf-8 -*- 
# (see pep-0263  for coding string)


"""gen-makefile.py - Generate Makefile for ESX.

Run with parameter -h or --help for usage text.

This aims to replace the fmkmf utility and provide some additional functionality.
"""
# @author: Anton MÃ¥rtensson, Chalmers, February 2015

from __future__ import print_function

import argparse
import errno
import os
import re
import sys


DEFAULT_COMMAND = 'gfortran'
DEFAULT_MAIN_FILE = 'esx_tester.f90'


def make_dirs(path):
    if os.path.isdir(path):
        return
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass
        else:
            raise


class MakefileGenerator:

    def __init__(self, base_path, f90):
        self.base_path = base_path
        self.abs_base_path = os.path.abspath(base_path)
        self.f90 = f90
        self.dependencies = dict()
        self.modules = dict()

    def __call__(self, main_file, result_path, org_build_path):
        self.investigate_source_file(main_file)
        main_file = self.norm_path(main_file)
        result_path = self.norm_path(result_path)
        build_path = self.norm_path(org_build_path)
        # Some info.
        yield '# Makefile generated by gen-makefile.py'
        yield '# Main file: ' + main_file
        yield '# Result path: ' + result_path
        yield '# Build path: ' + build_path
        yield ''
        # Definitions.
        yield 'F90=%s -J %s' % (self.f90, build_path)
        yield ''
        # Phonies.
        yield '.PHONY: default clean'
        yield ''
        # Default make target.
        yield 'default: ' + result_path
        yield ''
        # Clean target.
        yield 'clean:'
        yield '\tfind %s -name \\*.o -delete' % build_path  # Remove object files.
        yield '\tfind %s -name \\*.mod -delete' % build_path  # Remove module files.
        #yield '\tfind %s -type d -empty -delete' % build_path  # Remove empty directories.
        yield ''

        def object_path(source_path):
            name, ext = os.path.splitext(os.path.basename(source_path))
            return self.norm_path(os.path.join(org_build_path, name + '.o'))

        needed_targets = set()
        emitted_targets = set()

        needed_targets.add(main_file)

        # Output dependencies.
        while len(needed_targets) > 0:
            source = needed_targets.pop()
            target = object_path(source)
            dependencies = [source]
            for use in self.dependencies[source]:
                if use not in self.modules:
                    print('Cannot find module', use, 'needed by', source, file=sys.stderr)
                    continue
                dependency = self.modules[use]
                if dependency == '':
                    continue
                dependencies.append(object_path(dependency))
                if dependency not in emitted_targets:
                    needed_targets.add(dependency)
            yield target + ': \\\n\t' + '\\\n\t'.join(dependencies)
            yield '\t$(F90) -o $@ -c $<'
            yield ''
            emitted_targets.add(source)

        # Output main link step.
        objects = [object_path(target) for target in emitted_targets]
        yield result_path + ': \\\n\t' + '\\\n\t'.join(objects)
        yield '\t$(F90) -o $@ $^'
        yield ''

    def ignore_module(self, module):
        self.modules[module.lower()] = ''

    def norm_path(self, path):
        norm = os.path.relpath(os.path.abspath(path), self.abs_base_path)
        norm = norm.replace('\\', '/')
        return norm if norm != '' else '.'

    def add_search_path(self, path):
        for name in os.listdir(path):
            file_path = os.path.join(path, name)
            if os.path.isfile(file_path) and file_path.lower().endswith('.f90'):
                self.investigate_source_file(file_path)

    def investigate_source_file(self, path):
        normed_path = self.norm_path(path)
        if normed_path in self.dependencies:
            return  # Already investigated.
        self.dependencies[normed_path] = set()
        with open(path, 'r') as file:
            find_end_module = False
            for line in file:
                # Look for use statements.
                match = re.match(r'\s*use\s+(\w+)', line, re.IGNORECASE)
                if match is not None:
                    # Add dependency to dictionary of files to dependency sets.
                    use = match.group(1).lower()
                    self.dependencies[normed_path].add(use)
                #
                if find_end_module:
                    # Search for end of module.
                    if re.match(r'\s*end module\s*$', line, re.IGNORECASE):
                        find_end_module = False
                else:
                    # Look for module declarations.
                    match = re.match(r'\s*module(?:\s+(\w+))?', line, re.IGNORECASE)
                    if match is not None:
                        find_end_module = True
                        if match.group(1) is None:
                            print('Unnamed module in', normed_path, file=sys.stderr)
                            continue
                        # Add module to dictionary of modules to files.
                        module = match.group(1).lower()
                        if module in self.modules:
                            print('Multiple providers of module', module, file=sys.stderr)
                            print('\tIgnoring', normed_path, 'for this module.', file=sys.stderr)
                        self.modules[module] = normed_path


def parse_cmd_line():
    parser = argparse.ArgumentParser(
            description='Generate Makefile for ESX.',
            epilog='Note that all paths are relative to the current working '
                   'directory, but that paths in the Makefile will be relative '
                   'to the Makefile.')
    parser.add_argument(
            'main_file',
            metavar='main-file', 
            type=str, 
            nargs='?', 
            default=DEFAULT_MAIN_FILE,
            help='the main Fortran file to compile (default: ' + DEFAULT_MAIN_FILE + ').')
    parser.add_argument(
            '-m', 
            dest='makefile', 
            metavar='path', 
            type=str, 
            default='Makefile',
            help='change the output destination (default: Makefile). '
                 'Any directories in this path will be created if necessary.')
    parser.add_argument(
            '--stdout', 
            dest='use_stdout', 
            action='store_true',
            help='output makefile contents to standard output. The Makefile specified by -m '
                 'will not be written to, but paths will still be relative to that path.')
    parser.add_argument(
            '-b',
            dest='build_path', 
            metavar='path', 
            type=str, 
            default=None,
            help='have the Makefile put build artifacts in this directory. '
                 'By default this is the same as the Makefile directory.')
    parser.add_argument(
            '-o', 
            dest='result_path', 
            metavar='path', 
            type=str, 
            default=None,
            help='set the primary compilation output for the Makefile.')
    parser.add_argument(
            '-p', 
            dest='search_path', 
            metavar='path', 
            type=str, 
            default=None,
            help='set the path(s) that source files are searched for. By default the '
                 'search path is only the path to the main file. Multiple paths may '
                 'be separated by semicolons.')
    parser.add_argument(
            '-i', 
            dest='ignore_module', 
            metavar='module', 
            type=str, 
            default=[], 
            action='append',
            help='ignore this module, whether it exists or not.')
    parser.add_argument(
            '-f90', 
            dest='f90', 
            metavar='command', 
            type=str, 
            default=None,
            help='specify the compilation command. By default this is taken from the '
                 'F90 environment variable, or "' + DEFAULT_COMMAND + '" if that does not exist.')
    return parser.parse_args()


def main():
    args = parse_cmd_line()
    # Default result path is the main file without extension.
    if args.result_path is None:
        args.result_path, dummy = os.path.splitext(args.main_file)
    # Default search path is the directory of the main file.
    if args.search_path is None:
        args.search_path = os.path.dirname(args.main_file)
        if args.search_path == '':
            args.search_path = '.'
    # Default build path is the directory of the makefile.
    if args.build_path is None:
        args.build_path = os.path.dirname(args.makefile)
        if args.build_path == '':
            args.build_path = '.'
    # Default compile command taken from environment.
    if args.f90 is None:
        args.f90 = os.environ.get('F90', DEFAULT_COMMAND)
    #
    base_path = os.path.dirname(args.makefile)
    generator = MakefileGenerator(base_path, args.f90)
    for module in args.ignore_module:
        generator.ignore_module(module)
    for path in args.search_path.split(';'):
        generator.add_search_path(path)
    #
    lines = generator(args.main_file, args.result_path, args.build_path)
    makefile_contents = '\n'.join(lines)
    #
    if args.use_stdout:
        print(makefile_contents)
    else:
        makefile_dir = os.path.dirname(args.makefile)
        if makefile_dir != '':
            make_dirs(makefile_dir)
        make_dirs(args.build_path)
        with open(args.makefile, 'w') as file:
            print(makefile_contents, file=file)


if __name__ == '__main__':
    main()
